import time

# Задание 1. Альтернативная реализация функции, определяющей чётность числа.
#
# P.S Позволил себе перевести название функции в snake case, так как это является общепринятым стандартом для Python
# (см. PEP 8), а также добавил строгую типизацию аргументов и возвращаемого значения.
#
# Также оставлю здесь приведённый в задании вариант для референса.
#


def isEven(value):
    return value % 2 == 0


# Я решил привести несколько вариантов реализации функции, т.к. условие задачи мне не совсем понятно.


def is_even_bin(value: int) -> bool:
    # Тут, конечно, было бы правильнее убрать not и переименовать функцию в is_odd_bin, но для соответствия приведённой
    # в задании функции сделал так.
    return not value & 1


def is_even_div(value: int) -> bool:
    return value // 2 * 2 == value


# Для начала о плюсах и минусах.
#
# Плюсы алгоритма из примера:
#
# 1.  Понятность. Даже будучи далёким от математики, не составит никакого труда понять, что остаток от деления
#     на 2 равен 0, если число чётное (т.к. оно делится на 2) и 1 - если нечётное.
#
# Минусы алгоритма из примера:
#
# 1.  Лишние операции. Нам вовсе не обязательно искать остаток для того, чтобы выяснить, является ли число чётным.
#
# Плюсы алгоритма is_even_bin:
#
# 1.  Наибольшая скорость.  Побитовые операции выполняются процессором быстрее всего.
#
# Минусы алгоритма is_even_bin:
#
# 1.  Непонятность. Определение чётности числа через побитовое И не является очевидным способом и для него требуется
#     дополнительное пояснение (его можно найти ниже).
#
# 2.  Неявное преобразование.  Ключевое слово not при взаимодействии с int возвращает bool, что может создать проблемы.
#
# Плюсы алгоритма is_even_div:
#
# 1.  Относительная понятность. Этот алгоритм сложнее приведённого в примере, но его всё ещё можно понять, зная, что
#     // является операцией деления нацело, результатом которой является частное от деления двух чисел с отсечённой
#     дробной частью.
#
# Минусы алгоритма is_even_div:
#
# 1. Лишняя сложность.  Из всех представленных вариантов этот алгоритм является наибольшим по количеству операций.
#
# 2. Наименьшая скорость. Из трёх представленных алгоритмов is_even_div показывает худший результат на любых массивах
#    чисел, время работы с которыми достаточно велико для измерения.

# Немного о is_even_bin
#
# В данной реализации функция совершает операцию побитового И переданного в неё числа и единицы и возвращает его
# инверсию, попутно неявно преобразуя ответ в bool.  Такая логика объясняется тем, что в бинарном представлении
# целого числа его младший бит всегда точно указывает на чётность или нечётность числа: цифра 1 на конце всегда
# указывает на нечётность числа, цифра 0 - на чётность. И именно этот младший бит мы получаем в результате операции
# побитового И числа и единицы.
#
# Почему это происходит?  Всё дело в двоичном представлении чисел.  Каждая цифра в двоичном числе
# является n-ой степенью двойки, помноженной на саму цифру (0 или 1).  Например, число 1010 в десятичной системе
# будет иметь вид 1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 0 * 2^0 = 8 + 0 + 2 + 0 = 10, а 111 будет равно
# 1 * 2^2 + 1 * 2^1 + 1 * 2^0 = 4 + 2 + 1 = 7.  И тут в дело вступает не самая очевидная закономерность.  Все степени
# двойки (за исключением нулевой) являются чётными числами, и потому единственным способом задать нечётное двоичное
# число является заполнение единицей самого младшего бита, который будет равен единице (нечётному числу) при переводе
# в десятичную систему.


if __name__ == '__main__':
    is_even_start_time = time.time()

    for i in range(-500000, 500001):
        isEven(5)

    print(f'isEven: execution time for 1000000 elements is {time.time() - is_even_start_time}')

    is_even_bin_start_time = time.time()

    for i in range(-500000, 500001):
        is_even_bin(5)

    print(f'is_even_bin: execution time for 1000000 elements is {time.time() - is_even_bin_start_time}')

    is_even_div_start_time = time.time()

    for i in range(-500000, 500001):
        is_even_div(5)

    print(f'is_even_div: execution time for 1000000 elements is {time.time() - is_even_div_start_time}')
